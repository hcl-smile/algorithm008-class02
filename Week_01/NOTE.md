### 第一周总结

#### 一、五毒神掌（无变刷题法：成为职业选手的方法）

1.第一遍刷题：
1）5 分钟读题+思考
2）没思路：直接看题解，注意，多解法！比较解法优劣
3）背诵和默写解法

2.刷题第二遍
1）马上自己写代码
2）多种解法比较，体会 -> 优化

3.刷题第三遍
1）隔了一天，再重复做题
2）不同解法得熟练程度 -> 专项练习

4.刷题第四遍
1）过了一周后：反复回来练习相同得题目

5.刷题第五遍
1）面试前一周，恢复性训练

#### 二、简单难度数组题心得

1.双指针（移动零）
解题思路：

```javascript
/**
 * 1.创建一个新指针j
 * 2.遍历数组索引i，当nums[i]项不等于0，则替换nums[j] = nums[i]，同时j++
 * 3.遍历索引j后的数组项，全部替换为0
 */

/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function (nums) {
  let j = 0;
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] !== 0) {
      if (i !== j) {
        nums[j] = nums[i];
        nums[i] = 0;
      }
      j++;
    }
  }
};
```

总结：双指针解法，对于数组项转换类型是比较常见的方法，避免了多层循环和其它 api 方法产生的额外时间复杂度，思路简单，逻辑清晰，时间复杂度为 O(n)

2.暴力解法（盛最多的水）
解题思路：

```javascript
/**
 * 两层嵌套循环
 * 1.遍历每对组合
 * 2.对比出每个组合得最大值
 * 3.输出最大值
 * 时间复杂度：0(n^2)
 */

/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function (height) {
  let max = 0;
  let len = height.length;

  for (let i = 0; i < len; i++) {
    for (let j = i + 1; j < len; j++) {
      let min = Math.min(height[i], height[j]);
      max = Math.max(max, min * (j - i));
    }
  }

  return max;
};
```

总结：所谓暴力解法就是基本的双层嵌套，解题思路简单直接，但是时间复杂度高，为 O(n^2)

3.递归（爬楼梯）
普通递归，解题思路：

```javascript
/**
 * 第三种方法
 * 解题思路：缓存递归
 * 时间复杂度: o(n)
 */

/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function (n, map = { 1: 1, 2: 2 }) {
  if (n < 2) {
    return 1;
  }

  if (map[n]) {
    return map[n];
  }

  map[n] = climbStairs(n - 1, map) + climbStairs(n - 2, map);

  return map[n];
};
```

总结：递归，其本质就是函数调用自身的一种算法思路，需要设定终止条件来防止程序无限循环导致栈溢出。
递归的时间复杂度一般为 O(n)，如上，给递归函数添加缓存操作是为了防止多余的计算，导致性能浪费，也
是递归的一种优化手段

#### 三、刷题总结

简单常见的数组算法解，主要常见的方法有暴力解法（嵌套循环），双指针，递归，其中递归和暴力解法都是时间复杂度对相对较高的解法。
暴力解法，时间复杂度更是高达 O(n^2)。虽然解法思路简单，直接，但是代价也是昂贵的。
其次再说递归，递归本质上就是自调用自身的一种解法，需要满足 2 个步骤：1）终止条件；2）调用自身。递归的隐藏风险就是，如果终止条件没有写对或写好，就会造成无限循环，最终导致栈溢出，造成程序崩溃。
因此，双指针解法，相比前两种解法来说，思路更为抽象，代码更为优雅，需要在理解的基础上进行运用，就能达到代码的最优解
